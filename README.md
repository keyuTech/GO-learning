GO notes

### Basics

- 每个GO程序都由包（package）构成
- 程序从main包开始运行
- 使用包需要通过路径导入
- 包名与导入路径的最后一个元素一致（"math/rand"的包名为rand）
- 使用圆括号"()"组合导入的包
- 包名首字母大写
- 导入包时只能使用导出时的包名
- 使用add添加参数，参数类型接在变量名之后
- 多个相同类型的参数，可以只在最后一个参数之后添加类型
- 一个函数可以返回任意数量的结果
```
func function_name([para_list]) [return_types] {
	函数体
}
```
- 返回值可以被命名，返回值的命名应当能反映出返回值的意义
- 使用"var"定义变量，同函数的参数，多个类型相同的变量可以在最后一个变量后添加类型
- 定义变量可以和包、函数同一级别
- "var"声明变量可以初始化，每个变量可以初始化一个值
- 如果变量声明时进行了初始化，则可以省略变量类型，变量类型与初始值类型相同
- ":="可以在函数内作为"var"的缩写并对变量赋值（"a := 1"等价于"var a = 1"）
- 对于函数外的每条语句都需要以关键字(keyword)开头
- 声明时没有初始化的变量的值为0，当变量是numeric类型时为数字0，bool类型时为false，string类型时为空字符串""
- 类型转换，使用表达式T(v)进行转换，表示将v类型转换为T类型
- 类型推导，在变量声明时未指定类型的情况下，该变量的类型由右侧值确定，若是为指定类型的数值常量则根据数值的精度确定
- 使用关键字"const"声明常量，常量的数据类型可以是character、string、boolean、numeric，且不能使用缩写形式":="

### Flow Control Statement（流控制语句）

- 只有一种循环结构： for循环
- for循环的初始化语句中声明的变量仅在for语句的作用域中可见
- for循环中没有"()"，大括号"{}"必须
- for循环中初始化语句和后置语句可选
- 不加判断条件则会无限循环
- 不加分号;的for循环可以当做while循环
- if语句无需小括号"()"，但大括号"{}"必须
- if在判断条件之前可以执行一个简单的语句，且声明的变量的作用域只在if语句内
- switch语句不需要break且case不必为常量和整数
- switch语句没有条件等同于switch true
- defer语句将函数推迟到外层函数返回之后执行
- 被defer的函数将被压入一个栈中，按照后进先出的顺序调用

### structs、slices和maps

- GO的指针保存了值的内存地址
- *T是指向T类型的指针，零值为nil
- &生成一个指向其操作数的指针
- 结构体(struct)是字段的集合
- 结构体指针可以访问结构体字段，eg: (*p).X，隐式间接引用p.X
- [n]T表示一个拥有n个T类型的值的数组
- 数组的长度是数组的一部分，因此不能改变数组的大小
- 切片[]T不固定大小，a[low: high]表示数组a中从low(包含)到high(不包含)的一个切片
- 切片并不存储数据，更改切片的元素会改变底层数组中对应的元素
- `[]int{1,2,3}`创建一个`[3]int{1,2,3}`的数组，并构建一个引用此数组的切片
- 切片的默认行为： 下界的默认值为0，上界的默认值是该切片（或数组）的长度
- 切片的长度：切片所包含的元素的个数，通过len(s)获取
- 切片的容量：从切片的第一个元素开始，到其底层数组末尾的个数，通过cap(s)获取
- 切片的零值表示长度和容量都为0且没有底层数组的切片，以nil表示
- make函数可以用来创建切片及动态数组，make函数会分配一个元素为零值的数组并返回一个引用此数组的切片
- ```make([]int, 5（长度）, 5（容量）)
,len = 5
,cap = 5```
- 切片可以包含任何类型，包括切片
- append函数向切片追加元素
- for循环的range形式可以遍历切片或映射，每次迭代都会返回当前元素对应的下标和值，可以使用_替代下标或值来忽略
- map创建映射，map的零值为nil
- 通过make函数创建map：`m := make(map[string]int)，m["张三"] = 1`
- 通过字面量的方法创建并初始化map：`m := map[string]int{"张三": 1, "李四": 3}`
- 创建一个nil的map：`var m map[string]int`
- map的键可以是任何值，可以是内置类型也可以是结构类型，但是map的键应该可以用"=="比较，因此切片、函数、含有切片的结构类型不能用于Map的键
- Map的值没有限制
- 在Map中插入或修改元素：`m[key] = value`
- 获取元素：`value = m[key]`，如果key不存在于map则为nil
- 删除元素：`delete(m, key)`
- 通过双赋值检测某个key是否存在：`value, ok = m[key]`，如果key在m中，则ok为true，否则ok为false，如果key不在map中，value是nil


### Methods and Interfaces

- GO没有类（class）
- 可以为结构体struct和非结构体定义方法，但是只能为同一个包内定义的类型的接收者声明方法
- method是一类带有特殊的‘接收者’参数的函数，method接收者在他自己的参数列表内，位于func关键字和方法名之间
- method与接收者绑定，称这个method为接受者的方法
- ```
type Vertex struct {
	X, Y float64
};
func (v Vertex) Abs () float64 {
	函数体
}
```
Abs方法拥有一个名为v，类型是Vertex的receiver

- method只是个带接收者参数的func
- 指针接收者的method可以修改接收者指向的值，由于方法经常需要修改它的接收者，指针接收者比值接收者更常用
- 接受一个值作为参数的函数必须接受一个指定类型的值
- 以值作为接收者的方法被调用时，接收者既能为值又能为指针
- 使用指针接收者的原因：1）方法能够修改其接收者指向的值 2）可以避免在每次调用方法时复制该值，在类型为大型结构体时会更高效
- 一般来说，所有给定类型的方法都应该有值或指针接收者
- 接口是一种类型，是一组方法签名定义的集合
- 接口类型的变量可以保存任何实现了这些方法的值
- 类型通过实现一个接口的所有方法来实现该接口
- 类型实现接口无需专门显式声明
- 在接口内部，接口值可以看做包含值与其具体类型的元组```(value, type)```
- 接口值保存了一个具体底层类型的具体值
- 接口值调用方法时会执行其底层类型的同名方法
- 即使接口内的具体值为nil，方法仍然会被nil接收者调用
- 保存了nil具体指的接口自身并不为nil
- nil接口值既不保存值也不保存具体类型
- 为nil接口调用方法会产生运行时错误，因为接口的元组内并未包含能够指明该调用哪个具体方法的类型
- 指定了零个方法的接口值被称为空接口```interface{}```
- 空接口可以保存任何类型的值，因为每个类型至少实现了零个方法
- 空接口被用来处理未知类型的值
- 类型断言提供了访问接口值底层具体值的方式```t := i.(T)```，该语句断言接口值i保存了具体类型T，并将其底层类型为T的值赋予变量t
- 如果示例中的i并未保存T类型的值，会触发一个恐慌
- 类型断言可以返回两个值：其底层值以及一个报告断言是否成功的布尔值```t, ok := i.(T)```，若i保存了一个T，那么t将会是其底层值，ok则为true；否则t为零值，ok为false
- 类型选择将按顺序从几个类型断言中选择分支的结构
```javascript
switch v := i.(type) {
	case T:
		// v 的类型为 T
	case S:
		// v 的类型为 S
	default:
		// 没有匹配，v 与 i 的类型相同
}	
```
- Stringer是fmt包中定义的接口，是一个可以用字符串描述自己的类型
```
type Stringer interface {
    String() string
}
```
- ```error```值表示错误状态，为内建接口，返回一个```error```值，通过判断此值是否等于nil进行错误处理，```error```为nil时表示成功；非nil的```error```表示失败
- io包指定了```io.Reader```接口，表示从数据流的末尾进行读取
- ```io.Reader```接口的Read方法：```func (T) Read(b []byte) (n int, err error)```
- ```Read```用数据填充给定的字节切片并返回填充的字节数和错误值，在遇到数据流的结尾时，返回一个```io.EOF```错误

### 并发

- Go程（goroutine）是由Go运行时管理的轻量级线程

- ```f(x,y,z)```f,x,y,z的求值发生在当前的Go程中，f的执行发生在新的Go程中
- Go程在相同的地址空间中运行，因此在访问共享内存时必须进行同步
- 信道（channels）是带有类型的管道，可以使用<-发送或接收值
```
ch <- v // 将v发送至信道ch
v := <-ch // 从ch接收值并赋予v
```
"箭头"方向就是数据流的方向

- 信道在使用前必须创建：```ch := make(chan int)```
- 带缓冲的信道：将缓冲长度作为第二个参数提供给make初始化一个带缓冲的信道 ```ch := make(chan int, 100)```
- 当信道的缓冲区填满后，向其发送数据才会阻塞，缓冲区为空时，接收方会阻塞
- 发送者可通过```close```关闭一个信道以表示没有需要发送的值
- 接收者可以通过为表达式分配第二个参数来测试信道是否关闭，若没有值可以接收且信道已被关闭，那么在执行完```v, ok := <-ch```之后ok会被设置为false
- 只有发送者才能关闭信道
- 信道与文件不同，通常情况下无需关闭，只有在必须告诉接收者不再有值需要发送的时候才有必要关闭
- select语句使一个Go程可以等待多个通信操作
- select会阻塞到某个分支可以继续执行为止，这时就会执行该分支。多个分支都准备好时会随机选择一个执行
```
select {
	case i := <- c:
		// 使用i
	default:
		// 从c中接收会阻塞时执行
}
```
- select默认选择：当select中的其他分支都没有准备好时，default分支就会执行，为了不发生阻塞，可使用default
- 使用互斥锁保证每次只有一个Go程能够访问一个共享的变量：在代码前使用Lock，在代码后使用Unlock
